 ## 1. Что такое ООП? Зачем оно нужно? В ответ на какую проблему оно появилось? Ответ в формате "проблема-решение" 
 ООП - одна из парадигм программирования. Оно появилось при разработке больших программ с использованием **процедурного** программирования. Рассмотрим проблемы процедурного программирования 
 - 1) Изменение переменной в одном месте может повлиять на работу другой, находящейся в разных частях кода.
 - 2) Поиск причины ошибки занимает слишком много времени
 - 3) Изменения в структуре данных могут потребовать изменения во многих функциях, где задействована данная структура данных
 - 4) Низкая гибкость
 - 5) Изменения в логике также могут потребовать изменения во многих функциях
В общем, проблем у процедурного программирования немало, ООП же решает эти проблемы через **инкапсуляцию**, **наследование** и **полиморфизм**
1) Представим: У объекта животное есть свойство скорость, процедурное программирование меняло бы его значение напрямую, но ООП задействует **инкапсуляцию**, и изменить это свойство можно было бы только через методы "ускориться" и "остановиться".
Также про наследование и полиморфизм;
2) Представим: У нас есть три геометрические фигуры: круг, квадрат, треугольник. Логика для нахождения их площади может быть похожей, но нам бы пришлось исписать кучу строк кода, чтобы найти значение всех трёх фигур. Это указывает на их низкую гибкость и дублирование кода.
ООП поможет решить нам эту проблему с помощью **наследования** и **полиморфизма**. 
Итак, базовый класс фигура и три подкласса круг, квадрат и треугольник. В родительском классе будет находиться метод "вычислить площадь". Применим **полиморфизм** и **переопределим** метод вычисления площади в подклассах. Это намного удобнее, чем если бы мы вычисляли площадь для каждой отдельно.

Исходя из этого, мы можем понять, что ООП сильно упрощает наш код, делает его понятнее и решает многие проблемы.

## 2. Какие ещё парадигмы программирования есть?
Основные: 1. **императивное** (структурное, процедурное), мы описываем КАК нам добиться нужного результата, задачи выполняются последовательно, в том порядке, в каком они написаны, используются циклы и условия: for, while, if; **декларативное** (функциональное, логическое), такой стиль, где мы просто пишем, что нам нужно.
```java
public class Sum { // императивное программирование

    public static void main(String[] args) {
        int[] numbers = {100, 150, 250, 228, 720};
        int sum = 0;

        for (int i = 0; i < numbers.length; i++) {
            int currentNumber = numbers[i];
            sum = sum + currentNumber;
        }
    }
}
```
```java
public class Sum { // декларативное программирование
    public static void main(String[] args) {
        int[] numbers = {1, 2, 3, 4, 5};
        int[] sum = sum(numbers);
    }

    public static int sum(int[] numbers) {
return Arrays.stream(numbers)
        .sum();
    }
}
```
## 3. Что такое принцип единственной ответственности?
каждый класс должен отвечать в идеале только за одну вещь. у тебя не должно быть несколько причин для изменения 1 класса. Делает код понятнее и тесты легче писать
## 4. 3 принципа ООП: наследование, инкапсуляция , полиморфизм. Развернуто про каждый из них
1) Наследование - потомок при создании получает все свойства и методы родителя.
Родитель — это класс, на основе которого мы создаём что-то новое. Потомок (или дочерний элемент) — это то, что получилось при создании на основе класса или объекта. **Ключевое** действие при **переопределении методов** и **полиморфизме**
```java
class Cat extends AnimalInfo {
    // наследование, ключевое действие при переопределении методов и полиморфизме
}
```
2) Полиморфизм - это когда мы можем вызывать одни и те же методы у разных классов. Внутри они могут работать по разному, но внешне всё будет выглядеть одинаково. Ключевые действия при полиморфизме: переопределение метода и наследование класса
3) Инкапсуляция - Идея в том, чтобы программист пользовался только теми свойствами и методами, которые есть у класса или объекта и не лез внутрь. Именно для этого используют геттеры и сеттеры
```java
public class AnimalInfo {
    private String name;
    private int age;
    public static int howManyAnimals = 0;
// скрываем данные
public void setName(String name) {
        this.name = name;
    }
    
    public String getName() {
        return this.name
    }
// используем геттеры и сеттеры
}
```
## 5. Что такое геттеры и сеттеры? Зачем они нужны? Почему нельзя изменять поля напрямую?
геттер чтобы узнать значение свойства объекта, сеттер чтобы установить новое значение свойства. Изменять напрямую нельзя, потому что они нужны чтобы другой компонент не мог изменять поля класса
## 6. Что лучше: композиция или наследование? Когда и какое использовать?
Нельзя сказать, что один лучше другого.
**Композиция** - более строгий тип связи. При использовании композиции объект не только является частью какого-то объекта, но и не может принадлежать другому объекту того же типа. Если поле у нас имеет тип Класс, оно может содержать ссылку на другой объект этого класса, создавая таким образом связь между двумя объектами. Ключевое отношение - Имеет ли?
**Наследование** - потомок при создании получает все свойства и методы родителя. Ключевое отношение - Является ли?
Наследуем, если:
1) Когда один класс действительно является более специализированной версией другого. (Например, Ford это Car).
2) Когда мы хотим повторно использовать основную реализацию базового класса, иногда с небольшими модификациями.
3) Когда мы хотим использовать полиморфизм для обработки различных видов объектов единообразно.
4) Когда мы разрабатываете программу, где пользователи будут расширять ваш базовый функционал.
**Если это не ваш случай, то и **наследование** вам, скорее всего, будет нужно не часто. Но не потому, что надо "предпочитать" **композицию** **наследованию**, и не потому что она "лучше". Выбирайте то, что подходит наилучшим образом для конкретно вашей задачи.**
Но, всё же перечислю некоторые условия, при которых нам понадобится **композиция**.
Если:
1) Когда один класс имеет функциональность другого класса, но не является им по своей сути. (Например, Car имеет Engine, но Car не является Engine).
2) Когда хотим изменять поведение класса во время выполнения, заменяя его компоненты.
3) Когда хотим минимизировать связанность и увеличить гибкость и тестируемость кода.
## 7. Что такое модификаторы доступа? Какие есть в Java?
Модификаторы доступа - ключевые слова, которые регулируют уровень доступа к разным частям твоего кода
1) **Private** - наиболее строгий модификатор доступа, он ограничивает видимость данных и методов пределами одного класса, ограничение доступа к полям и реализация геттеров и сеттеров — самый распространенный пример использования private в работе.
```java
public class AnimalInfo {
    private String name;
    private int age;
}

public AnimalInfo(String name, int age) {
        // перегрузка конструктора
        this.name = name;
        this.age = age;
    }
public void setName(String name) {
        this.name = name;
    }

public void setAge(int age) {
        this.age = age;
    }

public String getName() {
        return this.name
    }

public int getAge() {
        return this.age
    }
```
2) **Package visible** (**Default**) - далее по списку. Он не обозначается ключевым словом, этот модификатор установлен для полей и методов по умолчанию. Если метод (или переменная) не помечены никаким модификатором, считается, что они помечены "модификатором по умолчанию". Допустим, если написать в коде 
```java
int x = 10
```
Модификатор для этого поля будет именно **Package visible** (**Default**)
3) **Protected** - следующий по строгости, редко используемый модификатор доступа.
Поля и методы такого модификатора будут видны в пределах всех классов-наследников нашего класса
Представим: Абстрактный класс секретный объект, от него наследуются три класса: Агент ФБР, Агент МИ-6, Агент Моссада. Мы хотим посчитать, сколько у нас агентов. При каждом создании объекта увеличиваем счётчик агентов на 1. Теперь мы хотим узнать, сколько у нас агентов. НО! Агенты то у нас секретные! Поэтому узнать их количество могут только сами агенты, для этого и нужен модификатор доступа **Protected**.
4) И, переходим к последнему, наверное, самому известному модификатору доступа - **Public**
Допустим: У нас есть программа - переводчик; метод, который переводит слова с английского на финский.
Пометим этот метод модификатором **Public** и он станет частью интерфейса

- И, пример из жизни для **Private** и **Public** модификаторов доступа, который я нашёл на JavaRush: **private** — это все процессы, происходящие внутри телевизора, когда он работает, а **public** — это кнопки на пульте телевизора, с помощью которых пользователь может им управлять. При этом ему не нужно знать как устроен телевизор и за счет чего он работает. Пульт — это набор **public-методов**: on(), off(), nextChannel(), previousChannel(), increaseVolume(), decreaseVolume() и т.д.
## 8. Чем отличается класс от объекта? 
Класс - чертёж дома, объект - дом
## 9. Что такое overloading?
Перегрузка метода, много методов с одним и тем же названием, в **ОДНОМ** классе, но разными **ПАРАМЕТРАМИ**
```java
public void infoAnimal(String name, int currentYear, int age) {
        System.out.println("Animal " + name + " was born " + (currentYear - age));
    }
    // базовый метод, который будем перегружать

    public void infoAnimal() {
        System.out.println("Animal: " + this.name + " is " + this.age + " years old");
    }```+
    // перегрузка метода
    // ПРОИСХОДИТ В ОДНОМ КЛАССЕ!!!
```
## 10. Что такое overriding?
Переопределение метода, много методов с одним и тем же названием, в **РАЗНЫХ** классах, но делают они разные **ЗАДАЧИ**
```java
public void voice() {
        System.out.println("Animals are making sounds");
    }
    // базовый метод, который будем переопределять

class Cat extends AnimalInfo {
    // наследование, ключевое действие при переопределении методов и полиморфизме
    public void voice() {
        System.out.println("meow");
    }
    // переопределение метода
}

class Dog extends AnimalInfo {
    //снова наследование
    @Override //при переопределении, как правило, пишется @Override
    public void voice() {
        System.out.println("WOOOF");
    }
    // переопределение метода
    // также полиморфизм
}
```

## 11. Чем отличается **overriding** от **overloading?**
**Override** (переопределение) выполняется в разных классах с помощью наследования, выполняет разные задачи; Overloading (перегрузка) выполняется в одном классе
## 12. Что такое конструктор? Когда он вызывается?
Конструктор вызывается при создании объекта и определяет его свойства (Цвет, скорость)
Например:
```java
Animal cat = new Animal(Black, 100); // вызываем новый объект, в конструкторе хранятся его свойства
```
## 13. Можно иметь несколько конструкторов? 
Да, это является **перегрузкой** конструкторов
## 14. Что такое дефолтный конструктор? 
Если программист не определил конструктор, создаётся дефолтный конструктор без параметров (он не будет отображён в коде, но он есть)
```java
Animal cat = new Animal(); // ПАРАМЕТРОВ НЕТ
```
## 15. Что такое статический метод?
Общий метод для класса, определяется ключевым словом **static**, вызывается с помощью названия класса
## 16. Что такое статическое поле? Где хранятся данные статического поля (в объекте или нет; если нет то где в памяти)? А где хранятся данные обычных non-static полей?
Общее поле для класса, оно может использоваться без создания объектов класса. Его данные хранятся в  **MetaSpace** - эта область памяти загружает данные класса (метаданные) во время выполнения программы. Когда класс загружается, его статические поля инициализируются и остаются в этой области памяти на протяжении всего времени жизни приложения; а вот non - static поля хранятся в самом объекте.
```java
public class AnimalInfo {
    private String name;
    private int age;
    public static int howManyAnimals = 0;
    // статистическое поле

    public static void currentAnimals() {
        System.out.println(howManyAnimals);
    }
    // статистический метод, вызывается с помощью названия класса, не требует создания объекта
}
```
## 16. Приведи пример полиморфизма 
```java
class Dog extends AnimalInfo {
    //снова наследование
    @Override //при переопределении, как правило, пишется @Override
    public void voice() {
        System.out.println("WOOOF");
    }
    // переопределение метода
    // также полиморфизм
}
```

## 17. Что такое Принцип подстановки Лисков (Liskov Substitution Principle, LSP)
Клиентский код должен слаженно работать с объектом дочернего класса (наследника), точно также, как и с объектом базового класса. В пример можно взять: Есть класс List. Есть два наследника FirstInFirstOutList и LastInFirstOutList: Следуя принципу, наследники по отношению к пользователю не взаимозаменяемы, потому что их поведение разное.
## 18. Что такое Duck Typing? Если это выглядит как утка, плавает как утка и крякает как утка, то это, вероятно, утка." Каким языкам оно присуще? В Java оно есть? 
Объект реализует интерфейс, если он содержит все методы этого интерфейса. в java нет, есть в питон и джаваскрипт из известных мне 
## 19. Что такое абстрактный класс? Зачем он нужен? 
Класс, чертёж, который максимально абстрактно описывает нужную нам сущность, объект такого класса нельзя создать. Такие классы используются для наследования
```java
public abstract class Animal {
    private String color;

    public abstract void run();

    public void color(String color) {
        this.color = color;
    }

    public String getColor() {
        return this.color;
    }
}
```
## 20. Что такое интерфейс? Зачем он нужен? 
Интерфейс определяет набор методов, который должны быть реализованы классом. Он описывает, **что** класс должен делать, без уточнения **как**.
Он нужен для:
 - Полиморфизма: мы можем написать код, который взаимодействует с объектом через его интерфейс, не зная конкретного класса этого объекта. Так мы можем создать обобщённый код.
 - Абстракции: Мы не знаем, как интерфейс выполняет заданный метод. Клиентский код, использующий интерфейс, не должен знать о внутренней работе конкретной реализации. Это упрощает разработку, тестирование и изменение кода.
 - Также интерфейсы уменьшают зависимость между классами, это делает программу устойчивее к изменениям
 - Java не поддерживает множественное наследование классов, но класс может реализовывать несколько интерфейсов. Это позволяет классу наследовать поведение от множества источников, не сталкиваясь с проблемами наследования, присущими множественному наследованию реализации.
Создадим интерфейс
```java
public interface Animal { // создаётся класс - интерфейс, где будет описаны методы, которые должы быть реализованы классом
    public void run();
}
```
Теперь оформим класс implements, который должен реализовать метод run
```java
public class Cat implements Animal {
    public void run() {
        System.out.println("Cat is running")
    }
```
## 21. Чем отличается абстрактный класс от интерфейса? 
Абстрактный класс хранит в себе абстрактные методы, а интерфейс объявляет методы, которые должны быть реализованы классом
## 22. Чем отличается extends от implements? 
1) Используя ключевое слово extends, класс может наследовать другой класс, а интерфейс может наследовать другие интерфейсы | Используя ключевое слово implements, класс может реализовать интерфейс.

extends
```java
public class Animal {
    public void run() {
        System.out.println("Animal is running");
    }

    public class Cat extends Animal {
        public void run() {
            System.out.println("Cat is running");
        }
    }
}
```
implements
```java
public interface Animal { // создаётся класс - интерфейс, где будет описаны методы, которые должы быть реализованы классом
    public void run();
}

public class Cat implements Animal {
    public void run() {
        System.out.println("Cat is running")
    }
```
2) Подклассу, расширяющему суперкласс, не обязательно переопределять все методы в суперклассе | Класс, реализующий интерфейс, обязан реализовать все методы этого интерфейса
3) Класс может расширять только один суперкласс | Класс может реализовывать любое количество интерфейсов одновременно
4) Любое количество интерфейсов может быть расширено интерфейсом. | Интерфейс может расширять другие интерфейсы, но не может реализовывать их
## 23. Можно наследоваться сразу от нескольких классов? Почему так?
Смотря от языка, в java нельзя, это приведёт к проблеме: метод, который будет вызываться в main классе просто не знает, метод какого класса ему выполнять; при этом, множественное наследование поддерживается в интерфейсах, потому что интерфейсы только объявляют методы, а реализация будет выполнена в классах
## 24. Можно имплементировать сразу несколько интерфейсов? Почему так?
Можно! В имплементирующем интерфейс классе должны быть реализованы все предусмотренные интерфейсом методы
## 25. Расскажи про статическую и динамическую типизацию. Плюсы и минусы каждого подхода.
Статически типизированные языки ограничивают типы переменных, Статические языки проверяют типы в программе во время компиляции, еще до запуска программы. Любая программа, в которой типы нарушают правила языка, считается некорректной. динамически типизированные языки не требуют указывать тип, но и не определяют его сами. Типы переменных неизвестны до того момента, когда у них есть конкретные значения при запуске.  Плюсы статистической: Скорость выполнения, Проверки типов происходят только один раз — на этапе компиляции. А это значит, что нам не нужно будет постоянно выяснять, не пытаемся ли мы поделить число на строку, При некоторых дополнительных условиях, позволяет обнаруживать потенциальные ошибки уже на этапе компиляции. Плюсы динамической: Легкость в освоении , удобство описания обобщенных алгоритмов
## 26. Расскажи про строгую и слабую типизацию. Плюсы и минусы каждого подхода
Сильная типизация выделяется тем, что язык не позволяет смешивать в выражениях различные типы и не выполняет автоматические неявные преобразования. Языки со слабой типизацией выполняют множество неявных преобразований автоматически, даже если может произойти потеря точности или преобразование неоднозначно. Плюсы сильной: Надежность — Вы получите исключение или ошибку компиляции, взамен неправильного поведения. Скорость — вместо скрытых преобразований, которые могут быть довольно затратными, с сильной типизацией необходимо писать их явно, что заставляет программиста как минимум знать, что этот участок кода может быть медленным, Понимание работы программы — опять-же, вместо неявного приведения типов, программист пишет все сам, а значит примерно понимает, что сравнение строки и числа происходит не само-собой и не по-волшебству, Определенность — когда вы пишете преобразования вручную вы точно знаете, что вы преобразуете и во что. Также вы всегда будете понимать, что такие преобразования могут привести к потере точности и к неверным результатам.
Преимущества слабой: Удобство использования смешанных выражений (например из целых и вещественных чисел), Абстрагирование от типизации и сосредоточение на задаче, Краткость записи.
## 27. Чем отличается статическая типизация от строгой? 
Они не являются противоположными, их нельзя сравнивать
## 28. Какая типизация в джаве?
Статистическая строгая
## 29. Почему в джава работает "println("My age is " + 24)"? Почему работает double a = 5 + 2.5?
1) В java, когда оператор "+" используется хоть с одним типом String, применяется не складывание чисел, а интерпретируется как оператор string concatenation
2) double a = 5 + 2.5 работает, потому что java автоматически приводит эти числа к одному типу данных, таким образом 5 становится 5.0

- Вычисляется выражение 5 + 2.5.

- int 5 автоматически преобразуется в double 5.0.

- Результат 7.5 (типа double) присваивается переменной a (типа double).
## 30. 5 принципов SOLID
1) Принцип единственной ответсвенности.
2) Принцип подстановки Лисков.
3) Принцип открытости/ закрытости - мы должны иметь возможность добавлять новую функциональность, не изменяя существующий код.
4) Принцип разделения интерфейсов - похож на принцип единственной ответственности.
5) Принцип инверсии зависимостей

